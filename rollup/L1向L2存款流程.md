# Optimism L1到L2存款流程

本文档详细描述了Optimism中从以太坊主网(L1)到Optimism链(L2)的存款流程，包括核心合约、代码实现和数据流。

## 1. 概述

Optimism的存款流程允许用户将ETH和ERC20代币从以太坊主网转移到Optimism链上。这个过程涉及多个智能合约的协作，以及Rollup节点对跨链事件的监听和处理。

主要参与者：
- **用户**：发起存款请求
- **L1智能合约**：处理存款请求并发出跨链事件
- **Rollup节点**：监听跨链事件并在L2上生成相应交易
- **L2智能合约**：接收并处理来自L1的存款

## 2. 核心合约

### 2.1 OptimismPortal2

`OptimismPortal2`是处理跨链消息的低级合约，负责在L1和L2之间传递消息。

- **文件位置**：`packages/contracts-bedrock/src/L1/OptimismPortal2.sol`
- **核心功能**：
  - 接收存款并发出`TransactionDeposited`事件
  - 处理ETH的锁定和释放
  - 验证和处理来自L2的提款

### 2.2 L1CrossDomainMessenger

`L1CrossDomainMessenger`提供了一个高级的消息传递接口，用户应该使用这个接口而不是直接与`OptimismPortal2`交互。

- **文件位置**：`packages/contracts-bedrock/src/L1/L1CrossDomainMessenger.sol`
- **核心功能**：
  - 封装了与`OptimismPortal2`的交互
  - 提供了消息重放保护
  - 处理消息的发送和接收

### 2.3 L1StandardBridge

`L1StandardBridge`负责在L1和L2之间转移ETH和ERC20代币。

- **文件位置**：`packages/contracts-bedrock/src/L1/L1StandardBridge.sol`
- **核心功能**：
  - 处理ETH的存款和提款
  - 处理ERC20代币的存款和提款
  - 与L2上的`L2StandardBridge`协作

### 2.4 StandardBridge

`StandardBridge`是`L1StandardBridge`和`L2StandardBridge`的基类，提供了桥接的核心逻辑。

- **文件位置**：`packages/contracts-bedrock/src/universal/StandardBridge.sol`
- **核心功能**：
  - 处理ETH桥接的核心逻辑
  - 处理ERC20代币桥接的核心逻辑
  - 提供了事件发射和权限控制

## 3. 存款流程详解

### 3.1 用户发起存款

用户通过调用`L1StandardBridge`的以下函数之一发起存款：

- `depositETH(uint32 _minGasLimit, bytes calldata _extraData)`：存款ETH
- `depositERC20(address _l1Token, address _l2Token, uint256 _amount, uint32 _minGasLimit, bytes calldata _extraData)`：存款ERC20代币

这些函数是为EOA(外部拥有账户)设计的，使用了`onlyEOA`修饰符。

**代码位置**：`packages/contracts-bedrock/src/L1/L1StandardBridge.sol:144-184`

```solidity
function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {
    _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);
}

function depositERC20(
    address _l1Token,
    address _l2Token,
    uint256 _amount,
    uint32 _minGasLimit,
    bytes calldata _extraData
) external virtual onlyEOA {
    _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);
}
```

### 3.2 初始化存款流程

`depositETH`和`depositERC20`函数分别调用`_initiateETHDeposit`和`_initiateERC20Deposit`，这些函数进一步调用`_initiateBridgeETH`和`_initiateBridgeERC20`。

**代码位置**：`packages/contracts-bedrock/src/L1/L1StandardBridge.sol:261-285`

```solidity
function _initiateETHDeposit(address _from, address _to, uint32 _minGasLimit, bytes memory _extraData) internal {
    _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _extraData);
}

function _initiateERC20Deposit(
    address _l1Token,
    address _l2Token,
    address _from,
    address _to,
    uint256 _amount,
    uint32 _minGasLimit,
    bytes memory _extraData
) internal {
    _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _extraData);
}
```

### 3.3 桥接逻辑实现

#### 3.3.1 ETH桥接

`_initiateBridgeETH`函数执行以下操作：
1. 验证发送的ETH金额
2. 发出`ETHBridgeInitiated`事件
3. 通过`messenger.sendMessage`将消息发送到L2

**代码位置**：`packages/contracts-bedrock/src/universal/StandardBridge.sol:309-329`

```solidity
function _initiateBridgeETH(
    address _from,
    address _to,
    uint256 _amount,
    uint32 _minGasLimit,
    bytes memory _extraData
) internal {
    require(msg.value == _amount, "StandardBridge: bridging ETH must include sufficient ETH value");

    _emitETHBridgeInitiated(_from, _to, _amount, _extraData);

    messenger.sendMessage{ value: _amount }({
        _target: address(otherBridge),
        _message: abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData),
        _minGasLimit: _minGasLimit
    });
}
```

#### 3.3.2 ERC20桥接

`_initiateBridgeERC20`函数执行以下操作：
1. 验证没有发送ETH
2. 如果是L2原生代币，则燃烧代币；否则，将代币存入合约
3. 发出`ERC20BridgeInitiated`事件
4. 通过`messenger.sendMessage`将消息发送到L2

**代码位置**：`packages/contracts-bedrock/src/universal/StandardBridge.sol:340-385`

```solidity
function _initiateBridgeERC20(
    address _localToken,
    address _remoteToken,
    address _from,
    address _to,
    uint256 _amount,
    uint32 _minGasLimit,
    bytes memory _extraData
) internal {
    require(msg.value == 0, "StandardBridge: cannot send value");

    if (_isOptimismMintableERC20(_localToken)) {
        require(
            _isCorrectTokenPair(_localToken, _remoteToken),
            "StandardBridge: wrong remote token for Optimism Mintable ERC20 local token"
        );

        IOptimismMintableERC20(_localToken).burn(_from, _amount);
    } else {
        IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);
        deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;
    }

    _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);

    messenger.sendMessage({
        _target: address(otherBridge),
        _message: abi.encodeWithSelector(
            this.finalizeBridgeERC20.selector,
            _remoteToken,
            _localToken,
            _from,
            _to,
            _amount,
            _extraData
        ),
        _minGasLimit: _minGasLimit
    });
}
```

### 3.4 消息传递

`L1CrossDomainMessenger`的`_sendMessage`函数负责将消息发送到L2：

**代码位置**：`packages/contracts-bedrock/src/L1/L1CrossDomainMessenger.sol:83-91`

```solidity
function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal override {
    portal.depositTransaction{ value: _value }({
        _to: _to,
        _value: _value,
        _gasLimit: _gasLimit,
        _isCreation: false,
        _data: _data
    });
}
```

### 3.5 存款事件

`OptimismPortal2`的`depositTransaction`函数发出`TransactionDeposited`事件，这是Rollup节点监听的关键事件：

**代码位置**：`packages/contracts-bedrock/src/L1/OptimismPortal2.sol:565-619`

```solidity
function depositTransaction(
    address _to,
    uint256 _value,
    uint64 _gasLimit,
    bool _isCreation,
    bytes memory _data
) public payable metered(_gasLimit) {
    if (_isUsingCustomGasToken()) {
        if (msg.value > 0) revert OptimismPortal_NotAllowedOnCGTMode();
    }

    if (_isUsingLockbox()) {
        if (msg.value > 0) ethLockbox.lockETH{ value: msg.value }();
    }

    if (_isCreation && _to != address(0)) {
        revert OptimismPortal_BadTarget();
    }

    if (_gasLimit < minimumGasLimit(uint64(_data.length))) {
        revert OptimismPortal_GasLimitTooLow();
    }

    if (_data.length > 120_000) {
        revert OptimismPortal_CalldataTooLarge();
    }

    address from = msg.sender;
    if (!EOA.isSenderEOA()) {
        from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);
    }

    bytes memory opaqueData = abi.encodePacked(msg.value, _value, _gasLimit, _isCreation, _data);

    emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);
}
```

## 4. Rollup节点处理

Rollup节点监听`OptimismPortal2`发出的`TransactionDeposited`事件，并在L2上生成相应的存款交易。以下是从节点启动到事件解析的完整流程：

### 4.1 节点启动与初始化

1. **节点启动**：运行`op-node`二进制文件，加载配置文件
2. **连接L1**：建立与L1以太坊节点的RPC连接
3. **初始化派生管道**：设置L1区块遍历器和交易派生器
4. **配置事件监听**：指定需要监听的`OptimismPortal2`合约地址和`TransactionDeposited`事件

### 4.2 L1区块同步与处理

1. **L1区块遍历**：
   - 从配置的起始区块高度开始同步L1区块
   - 使用`L1Traversal`组件按顺序获取L1区块
   - 跟踪当前处理的L1区块引用

2. **获取区块收据**：
   ```go
   // 从L1获取区块收据
   receipts, err := l1Client.TransactionReceipts(ctx, blockHash)
   ```
   - 对每个L1区块，获取所有交易的收据
   - 收据包含了交易产生的所有事件日志

3. **筛选相关事件**：
   - 遍历所有收据中的事件日志
   - 筛选出`OptimismPortal2`合约地址发出的日志
   - 进一步筛选出`TransactionDeposited`事件（通过事件签名判断）

### 4.3 事件解析

节点通过`UnmarshalDepositLogEvent`函数解析`TransactionDeposited`事件：

**代码位置**：`op-node/rollup/derive/deposit_log.go:35-97`

```go
func UnmarshalDepositLogEvent(ev *types.Log) (*types.DepositTx, error) {
    // 验证事件格式
    if len(ev.Topics) != 4 {
        return nil, fmt.Errorf("expected 4 event topics, got %d", len(ev.Topics))
    }
    if ev.Topics[0] != DepositEventABIHash {
        return nil, fmt.Errorf("invalid deposit event selector")
    }

    // 提取事件数据
    from := common.BytesToAddress(ev.Topics[1][12:])
    to := common.BytesToAddress(ev.Topics[2][12:])
    version := ev.Topics[3]
    opaqueData := ev.Data[64 : 64+opaqueContentLength.Uint64()]

    // 解析opaqueData
    var dep types.DepositTx
    switch version {
    case DepositEventVersion0:
        err = unmarshalDepositVersion0(&dep, to, opaqueData)
    default:
        return nil, fmt.Errorf("invalid deposit version")
    }

    return &dep, nil
}
```

### 4.2 生成L2交易

`unmarshalDepositVersion0`函数将事件数据转换为L2上的`DepositTx`：

**代码位置**：`op-node/rollup/derive/deposit_log.go:99-141`

```go
func unmarshalDepositVersion0(dep *types.DepositTx, to common.Address, opaqueData []byte) error {
    // 解析opaqueData中的字段
    offset := uint64(0)

    // uint256 mint
    dep.Mint = new(big.Int).SetBytes(opaqueData[offset : offset+32])
    offset += 32

    // uint256 value
    dep.Value = new(big.Int).SetBytes(opaqueData[offset : offset+32])
    offset += 32

    // uint64 gas
    gas := new(big.Int).SetBytes(opaqueData[offset : offset+8])
    dep.Gas = gas.Uint64()
    offset += 8

    // uint8 isCreation
    if opaqueData[offset] == 0 {
        dep.To = &to
    }
    offset += 1

    // 交易数据
    dep.Data = opaqueData[offset:]

    return nil
}
```

## 5. L2处理

在L2上，Rollup节点生成的`DepositTx`被执行，完成存款过程。这里详细解释您的疑问：

### 5.1 DepositTx是什么？

`DepositTx`是L2上的一种特殊交易类型，**不是普通的L2用户交易**，而是由Rollup节点根据L1上的`TransactionDeposited`事件生成的系统交易。它具有以下特点：

- 由系统自动生成，无需签名
- 包含了从L1传递过来的消息数据
- 会自动触发L2上的相应操作

### 5.2 资金来源

#### ETH存款资金来源：
- L1上用户的ETH被锁定在`L1StandardBridge`合约中
- Rollup节点生成的`DepositTx`包含了一个`Mint`字段，指定了要在L2上"创建"的ETH数量
- L2执行环境会直接增加接收者的ETH余额，相当于在L2上凭空"创建"这些ETH（但受L1锁定的ETH背书）

#### ERC20存款资金来源：
- 如果是**Optimism Mintable ERC20代币**：在L2上直接铸造新代币（由`IOptimismMintableERC20(_localToken).mint(_to, _amount)`实现）
- 如果是**非本地代币**：从L2StandardBridge合约的托管余额中转移（这些代币是之前从L2提款回L1时托管的）

### 5.3 L2StandardBridge调用机制

**为什么会调用L2StandardBridge合约？**

当用户在L1上调用`L1StandardBridge.depositETH`或`depositERC20`时，L1StandardBridge会：
1. 处理L1上的资金（锁定ETH/托管/销毁ERC20）
2. 通过`L1CrossDomainMessenger`发送一个跨链消息
3. 这个消息包含了**调用L2StandardBridge的`finalizeBridgeETH`或`finalizeBridgeERC20`函数的指令**

   **具体代码位置**：
   - ETH存款：`StandardBridge.sol`的`_initiateBridgeETH`函数中（第326行）：
     ```solidity
     _message: abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData),
     ```
   - ERC20存款：`StandardBridge.sol`的`_initiateBridgeERC20`函数中（第371-382行）：
     ```solidity
     _message: abi.encodeWithSelector(
         this.finalizeBridgeERC20.selector,
         _remoteToken,  // 注意：token顺序在远程链上会反转
         _localToken,
         _from,
         _to,
         _amount,
         _extraData
     ),
     ```

   这些代码使用`abi.encodeWithSelector`将函数调用信息编码为字节数组，作为跨链消息的内容。

**哪里触发调用？**

1. L1上的`OptimismPortal2`合约将包含L2StandardBridge调用指令的消息打包到`TransactionDeposited`事件中
2. Rollup节点解析该事件，生成`DepositTx`
3. `DepositTx`的`Data`字段包含了调用L2StandardBridge的函数签名和参数
4. 当L2执行环境处理这个`DepositTx`时，就会自动调用L2StandardBridge的相应函数

### 5.4 具体执行流程

1. **ETH存款执行**：
   ```solidity
   function finalizeBridgeETH(
       address _from,
       address _to,
       uint256 _amount,
       bytes calldata _extraData
   ) public payable onlyOtherBridge {
       // 验证金额和接收地址
       require(msg.value == _amount, "StandardBridge: amount sent does not match amount required");
       require(_to != address(this), "StandardBridge: cannot send to self");
       require(_to != address(messenger), "StandardBridge: cannot send to messenger");

       // 直接将ETH发送到接收地址
       bool success = SafeCall.call(_to, gasleft(), _amount, hex"");
       require(success, "StandardBridge: ETH transfer failed");
   }
   ```
   注意：这里的`msg.value`就是`DepositTx`中的`Mint`字段指定的金额。

2. **ERC20存款执行**：
   ```solidity
   function finalizeBridgeERC20(
       address _localToken,
       address _remoteToken,
       address _from,
       address _to,
       uint256 _amount,
       bytes calldata _extraData
   ) public onlyOtherBridge {
       if (_isOptimismMintableERC20(_localToken)) {
           // 对于Optimism Mintable ERC20，直接铸造新代币
           IOptimismMintableERC20(_localToken).mint(_to, _amount);
       } else {
           // 对于非本地代币，从托管余额中转移
           deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;
           IERC20(_localToken).safeTransfer(_to, _amount);
       }
   }
   ```

### 5.5 关键技术点

- **跨链消息传递**：整个过程依赖于L1到L2的跨链消息传递机制，由`L1CrossDomainMessenger`和`OptimismPortal2`合约实现
- **Rollup节点角色**：Rollup节点负责监听L1事件并生成对应的L2交易，是连接L1和L2的桥梁
- **系统交易**：`DepositTx`作为系统交易，绕过了普通交易的签名验证，确保跨链操作的可靠性
- **资金背书**：L2上"创建"的资金始终由L1上锁定/托管的资金背书，保证了跨链资产的安全性

## 6. 数据流程图

```
用户
  │
  ▼
L1StandardBridge.depositETH/ERC20
  │
  ▼
_initiateBridgeETH/ERC20
  │
  ▼
L1CrossDomainMessenger.sendMessage
  │
  ▼
OptimismPortal2.depositTransaction
  │
  ▼
发出TransactionDeposited事件
  │
  ▼
Rollup节点监听并解析事件
  │
  ▼
在L2上生成DepositTx
  │
  ▼
执行DepositTx
  │
  ▼
完成存款
```

## 7. 安全考虑

1. **金额验证**：确保发送的ETH金额与存款金额一致
2. **Gas限制**：设置适当的Gas限制，防止交易失败
3. **地址别名**：合约调用时使用地址别名，避免重入攻击
4. **事件解析**：严格验证事件格式，防止恶意事件注入
5. **权限控制**：使用修饰符限制函数调用权限

## 8. 常见问题

### 8.1 存款需要多长时间？

存款通常在几分钟内完成，具体取决于L1的确认时间和Rollup节点的处理速度。

### 8.2 存款费用是多少？

存款费用包括：
1. L1交易费用
2. L2执行费用

### 8.3 如何跟踪存款状态？

可以通过以下方式跟踪存款状态：
1. 在Etherscan上查看L1交易
2. 在Optimism Explorer上查看相应的L2交易
3. 监听`TransactionDeposited`事件

## 9. 代码优化建议

1. **批量处理**：考虑支持批量存款，减少交易费用
2. **Gas预估**：改进Gas预估机制，提高用户体验
3. **错误处理**：增强错误处理和日志记录，便于调试
4. **文档完善**：添加更多注释和文档，提高代码可维护性

## 10. 总结

Optimism的L1到L2存款流程是一个复杂但高效的跨链机制，通过智能合约和Rollup节点的协作，实现了资产在以太坊主网和Optimism链之间的安全转移。了解这个流程对于开发人员和用户来说都非常重要，可以帮助他们更好地理解Optimism的工作原理和使用方法。