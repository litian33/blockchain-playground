# DEX 常见 50 题

---

## 基础概念（1–8）

1. **什么是 DEX？和 CEX 的根本区别是什么？**
   **答：** DEX（去中心化交易所）是一类在区块链上运行、通过智能合约撮合或自动做市的交易平台。与 CEX（中心化交易所）不同：资产 custody（托管）上用户自持私钥（非托管）、撮合和结算在链上或由智能合约执行、更高的透明度但通常吞吐和 UX 较弱、监管与 KYC 模式不同。

2. **什么是 AMM（自动做市商）？为何它能替代订单簿？**
   **答：** AMM 用数学公式（如 x*y=k）替代传统订单簿，通过流动性池让用户与池子交易。优点：简单、无需全局订单簿、任何人在任意价格区间提供流动性；缺点：滑点、无常损失。

3. **解释 x * y = k 模型的含义与限制。**
   **答：** 两代币储备量 x, y 的乘积保持常数 k。交易会改变储备，导致价格发生变化（由储备比决定）。限制：资金效率低、对价格区间无法集中、对大额交易滑点高。

4. **什么是集中流动性（Concentrated Liquidity / V3）？优点？**
   **答：** LP 在价格区间内集中提供流动性（而非对所有价格均匀分布），可极大提高资本效率、降低滑点。代价：实现更复杂（tick、sqrtPrice、NFT 表示头寸）、LP 需管理范围。

5. **什么是 LP token？V2 与 V3 有何区别？**
   **答：** LP token 表示流动性份额。V2 通常为 ERC20 表示所有池内流动性份额；V3 中每个 LP 头寸是独立的区间配置，因此用 NFT 表示独一无二的头寸。

6. **什么是 TWAP？为什么 DEX 要用 TWAP？**
   **答：** TWAP（Time-Weighted Average Price）是时间加权平均价格，用来抗短期操纵和闪电贷攻击。可用于提供更稳定的价格参考（例如做为 on-chain oracle）。

7. **什么是闪电贷（Flash Loan）？有什么典型风险？**
   **答：** 无需抵押，借款在单个交易内借出并归还。被用于合法套利，也可被用于操纵市场（借大量资产操纵价格，再利用合约逻辑获利）或触发合约漏洞。

8. **什么是无常损失（Impermanent Loss）？如何降低？**
   **答：** LP 在价格大幅波动时，相比单持有代币会产生相对损失。降低方式：提供给低波动配对（稳定币、挂钩资产）、使用集中流动性、使用动态费率或保险机制。

---

## 智能合约与 AMM 细节（9–18）

9. **解释 Uniswap V2 Pool 的 swap 流程要点。**
   **答：** 用户调用 swap，合约接收输入代币，计算输出按 x*y=k 保持（扣除手续费），检查输出不超过池内储备，交换两侧储备并更新状态，发出事件。

10. **V3 的 tick、sqrtPrice、liquidity 三者关系是什么？**
    **答：** tick 对应离散化的价格索引；sqrtPrice（通常是价格的平方根）用于数值稳定的流动性计算；liquidity 表示当前价格区间内的可用流动性。数学上 price = (sqrtPrice)^2。流动性与价格区间边界、sqrtPrice 的变化关系决定了 token 的数量变化。

11. **如何计算某笔交易在 AMM 中的滑点？**
    **答：** 滑点 = 1 -（执行价格 / 市场发起价格）。在 x*y=k 模型，给定输入量 Δx，输出 y' = y - k/(x+Δx)，执行价格 = Δx / (y - y')。（面试只需说明代数关系与概念即可）

12. **什么是路由（Router）合约，为什么需要它？**
    **答：** Router 封装复杂路径计算（多 hop）、批准、传参以及最优路径查找，简化前端与用户交互，处理代币兑换的多步骤事务。

13. **如何在合约内安全地处理 ERC20 的 transfer/approve？**
    **答：** 使用 OpenZeppelin 的 SafeERC20 wrapper（检查返回值、兼容非标准 ERC20）、避免在同一 tx 多次 reduce allowance 的 race（使用 increase/decreaseAllowance），对外部调用用 checks-effects-interactions 模式并防重入。

14. **合约中如何表示费率和精度问题？**
    **答：** 常用整数表示比例（例如以 basis points 或 1e6、1e18 单位），避免浮点。确保所有乘除有正确顺序（先乘后除）并处理溢出/下溢（Solidity 0.8+ 有内置检查）。

15. **如何在合约中实现 TWAP oracle？**
    **答：** 记录周期性价格快照（price * timestamp），或累积价格（cumulative price）并在区间内计算平均。核心是记录累计价格与时间戳，并使用差值除以时间差得出 TWAP。

16. **为什么要用 sqrtPrice 而不是直接 price？**
    **答：** 在计算流动性与 token 数量变换时，sqrt(price) 使公式线性化、数值范围更稳定，减少反复开根号/平方导致的精度误差。

17. **设计一个简单的 fee-on-transfer 代币，合约要注意什么？**
    **答：** fee 在 transfer 时会扣除，需确保合约在处理此类代币时正确计算实际到账金额（一些合约假设 transfer 返回值或余额行为，会出错）。使用 SafeERC20 处理并测试兼容性。

18. **如何设计 Pool 的可升级性？（治理/代理模式）**
    **答：** 常见策略：使用代理合约 + 可升级逻辑（透明代理或 UUPS），或把可变参数（如 fee）暴露到 Factory 或治理合约控制。关键是最小化可升级面、用治理多签和时间锁限制升级。

---

## 链下服务与索引（19–25）

19. **为什么 DEX 需要链下 indexer？The Graph 的作用是什么？**
    **答：** 链上直接查询事件/状态成本高且慢，indexer 将事件解析并存入 DB 以高效查询。The Graph 提供 subgraph 框架解析事件、REST-like API，提高开发效率与可组合性。

20. **如何用日志（event）设计合约便于索引？**
    **答：** 尽量将关键状态变更通过事件导出（例如 Swap、Mint、Burn、Sync），事件参数清晰且带必要索引（indexed）字段，防止把重要信息仅存在 storage 中不便解析。

21. **如何把 K 线（OHLC）数据从链上生成？基本思路？**
    **答：** Indexer 按时间分桶（如 1m/5m），每个桶统计开高低收与成交量。实现：监听 Swap 事件，按 timestamp bucket 聚合并写入 ClickHouse/Postgres，每次新 event 更新对应桶。

22. **何时自建 Indexer 比用 The Graph 更合适？**
    **答：** 需要极高吞吐、低延迟或自定义复杂聚合与回溯查询时自建；The Graph 更适合快速开发与社区共享 subgraph。

23. **如何保证 indexer 的一致性与从链重组（reorg）处理？**
    **答：** 使用区块确认策略（等待 N 确认再写入最终数据），detect reorg 并回滚/重建受影响区块的数据，保持 idempotent 的更新逻辑。

24. **如何实现路径查找与路由优化（SOR）？**
    **答：** 构建图（token 为节点，池为带权边），用变体的最短路径算法（考虑价格、滑点、手续费）或多路径分拆（线性规划或启发式）模拟不同分配，选择最大输出或最低成本。

25. **Indexing 常用的数据库选择及为何？**
    **答：** PostgreSQL（事务、关系型查询）、ClickHouse（高吞吐 OLAP，适合 K 线与聚合）、Redis（缓存）、Elasticsearch（复杂搜索）。按查询模式混合使用。

---

## 前端与 UX（26–31）

26. **前端如何与智能合约交互（典型 stack）？**
    **答：** React + TypeScript 前端，使用 wagmi/viem 或 ethers.js 与钱包（MetaMask / WalletConnect）连接，调用 read/write RPC，显示交易模拟与滑点提示，处理批准（approve）流程并展示 tx 状态。

27. **如何在前端做交易模拟以显示预计输出？**
    **答：** 使用 callStatic/staticcall 或者 local RPC eth_call 进行模拟（不变更链上状态），并结合 indexer 的深度数据评估滑点和可用深度。

28. **如何设计前端避免用户被 sandwich 攻击？**
    **答：** 给用户显示较低滑点、支持 slippage tolerance 设置、提供交易预测和 nonce 管理，建议使用 private RPC / Flashbots bundle（把交易打包提交，减少 mempool 暴露）。

29. **为什么要做 approve UX 优化？有哪些常用做法？**
    **答：** approve 是频繁的阻力点。优化：一次性无限 approve（有安全考量）、使用 permit（EIP-2612）免 approve、使用钱包内签名代替交易（gas 优化）。

30. **前端如何处理代币小数差异与显示精度？**
    **答：** 后端/前端统一用整数最小单位（如 wei），仅在 UI 做格式化显示，避免四舍五入误导并在交易提示中显示精确值及数位说明。

31. **如何实现多路径选择的 UI 给用户透明度？**
    **答：** 在交易确认页显示路由细节（经过哪些池、每段比例、预估输出与手续费），并提供“高级”折叠查看，默认隐藏复杂信息以简化 UX。

---

## 交易执行、聚合与 MEV（32–37）

32. **什么是 MEV？为什么它对 DEX 用户重要？**
    **答：** Miner/Maximal Extractable Value（或 MEE）指矿工/验证者通过重排、插入、删减交易在区块中提取的可获利行为（如前置、夹层）。对用户重要因为会导致用户被夹击（sandwich）或交易被抢（front-run），造成更高成本或失败。

33. **Flashbots 的作用是什么？如何防 MEV？**
    **答：** Flashbots 提供私有交易传递给矿工/验证者（不进入公共 mempool）并以 bundle 方式打包，减少被抢的风险。它不是完全防御，但可以把部分交易从公开 mempool 隐藏。

34. **交易打包（bundle）与普通交易有什么不同？**
    **答：** bundle 将多个 tx 一起打给矿工并要求按顺序一起执行或不执行（原子性），可能包含回滚逻辑，从而实现复杂策略或保护用户免遭 mempool 攻击。

35. **什么是 slippage tolerance？前端如何提示合理值？**
    **答：** 用户可允许的最大价格变动百分比，超出则交易回退。前端提示基于池深度、历史波动，默认 0.5%-1%（或用户可自设），并提示大额交易需更高注意。

36. **聚合器如何分配交易到多个 DEX？**
    **答：** 通过路由算法（模型化每个池的价格曲线），对分割后的子交易求解最优分配（可用动态规划或启发式），目标最大化输出或最小化滑点与手续费。

37. **如何在链下模拟算出 gas 与回退概率？**
    **答：** 使用节点的 eth_call / simulate 或 Tenderly、Hardhat 的 fork 模式做本地回放，检查调用是否会 revert，并估算 gas 使用；考虑最近区块的 nonce、baseFee 波动与合约状态变更导致的回退概率。

---

## 安全与审计（38–43）

38. **DEX 常见合约漏洞有哪些？如何防范？**
    **答：** 常见：重入、价格操纵、整数溢出、权限错误、逻辑错误（fee 分配）、不安全外部调用、缺乏 input validation。防范：使用 checks-effects-interactions、对外部合约调用加限制、用 OpenZeppelin、静态分析（Slither）、模糊测试（Foundry/Echidna）、审计与赏金。

39. **什么是重入攻击，如何防范？**
    **答：** 外部合约在回调时再次调用受害合约的敏感函数，导致不一致状态。防范：checks-effects-interactions（先变更状态再调用外部）、使用 reentrancy guard（互斥）、限制外部回调。

40. **如何审计 AMM 的数学实现是否正确？**
    **答：** 校验边界条件、精度（定点数处理）、sqrt/log/exp 的实现与输入域、tick 转换的双向一致性、手续费计算、重入与 overflow 情形，编写 invariants（不变量）以及大量单元与 fuzz 测试。

41. **如何测试合约对 oracle 操纵的鲁棒性？**
    **答：** 在测试中模拟 oracle 报价被攻击（快速变动），以及 oracle 延迟/失效情形，验证合约在极端价格下的行为（是否有保护、是否会被清算或亏损）。

42. **如何评估 LP 的无常损失，并设计补偿机制？**
    **答：** 模拟不同价格路径并比较 LP 与 HODL 收益，设计补偿可用动态手续费、保险金池、收益分红、或使用外部保险协议。面试回答应展示理解与可行的减损措施。

43. **合约升级后如何保证安全？**
    **答：** 使用 time-lock、多签治理、最小化可升级面、对升级逻辑进行审计、发布变更公告并在 testnet 做回归测试，必要时逐步开启（feature flags）。

---

## 开发工具、测试与范式（44–47）

44. **Foundry、Hardhat、Truffle 的区别与各自优劣？**
    **答：** Hardhat：JS 生态，插件丰富，好上手；Foundry（forge）：Rust 实现、速度快、强测试与 fuzz 支持，适合高性能测试；Truffle：老牌但生态逐渐弱。现代偏向 Hardhat + Foundry 混合（Foundry 作测试/快速 fuzz，Hardhat 做脚本/前端集成）。

45. **什么是 invariant testing？为什么重要？**
    **答：** 不变量测试是指定义系统应始终满足的性质（例如总流动性守恒、token 总量不变），用随机化或模糊输入（fuzz）验证这些性质在大量路径下成立。重要性：捕捉复杂交互下的逻辑漏洞。

46. **如何设计一套全面的 CI 测试流程来发布合约？**
    **答：** 包含 lint（solhint）、静态分析（Slither）、单元测试（Foundry/Hardhat）、invariant & fuzz 测试、形式化 check（如可用）、部署脚本在 testnet 自动回放、审计报告整合与自动化代码覆盖率检查。

47. **如何在本地使用 mainnet fork 做集成测试？要注意什么？**
    **答：** 使用 Hardhat/Foundry 的 fork 功能把主网状态拉到本地，进行模拟交易、攻击场景测试。注意事项：保持 fork block number 固定以重现性、处理外部依赖（oracles、off-chain 服务）、确保私钥和资金管理在测试环境安全。

---

## 运维、监控与生产问题（48–50）

48. **Dex 生产环境要监控哪些关键指标？**
    **答：** TVL、每日交易量、交易失败率（reverts）、平均滑点、池子深度、nonce/tx backlog、节点连接率、indexer 延迟、gas 使用、异常大额交易告警及智能合约事件的异常（如大量 Burn/Mint）。

49. **如何应对节点或 indexer 的宕机？有无容灾策略？**
    **答：** 多节点多提供商（自建 + Alchemy/Infura/QuickNode）、自动切换与健康检测；indexer：主从冗余、checkpoint 与重播能力、日志与 alert，使用消息队列（Kafka）保证事件不丢失，快速回滚/重建策略。

50. **设计一个高可用的 DEX 架构要点有哪些？**
    **答：** 多层冗余（RPC、indexer、API）、读写分离、缓存（Redis）降低 DB 压力、异步任务队列、限流与熔断、防 DDoS、部署在 k8s + 自动伸缩、使用监控与告警回路、审计与备份机制、并对重大变更做灰度发布与回退计划。

