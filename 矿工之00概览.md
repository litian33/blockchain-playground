
---

# 完整矿工出块逻辑

这是一条从 **P2P → TxPool → 执行器 → 状态 → 共识 → 区块生成 → 广播** 的完整流水线。

---

# 一、矿工整体流水

可以分成 **六大阶段**：

```
┌────────┐
│ ① 接收交易 │  <-- P2P / RPC / 本地交易
└────┬────┘
     ▼
┌────────┐
│ ② 进入交易池 │  <-- LegacyPool + BlobPool
└────┬────┘
     ▼
┌────────┐
│ ③ 出块准备(Pre-mining) │
│  - 获取共识建议的 parent block
│  - 获取共识要求的 extra data / difficulty / gas limit
│  - 构造 BlockContext/TxContext │
└────┬────┘
     ▼
┌────────┐
│ ④ 交易选择(调度/拍卖/打包) │
│  - pending tx 按优先级选择
│  - blob tx 限额 + 冲突、nonce 严格递增
│  - 多队列、多优先级
└────┬────┘
     ▼
┌────────┐
│ ⑤ 执行交易(状态机) │
│  - EVM/Interpreter
│  - Gas 会计
│  - 状态变更(账户/存储/日志)
│  - receipt + bloom
└────┬────┘
     ▼
┌────────┐
│ ⑥ 构造区块 & 共识提交 │
│  - 写入 receipts root, logs bloom
│  - 写入 tx trie root / blob commitments
│  - 共识引擎签名/Seal()
│  - 广播新区块
└────────┘
```

这是任何 PoW / PoS / BFT / OP Stack L2 都共享的结构，只是 **共识模块（Seal / Verify seal / Prepare header）** 不同。

---

# 二、矿工的关键组件与 **共识接口**

为了使矿工出块逻辑与具体共识算法解耦，Geth/rollup-node 中共识引擎必须向 Miner 提供以下能力：

---

## 2.1 共识接口

共识模块（例如 ethash / clique / beacon / op-consensus）需要向矿工暴露：

### **① Prepare()**

输入：`header`（未填 difficulty、extra、mixDigest 等）
输出：填充好共识相关字段的 header
作用：

* 设置 difficulty（PoW）
* 设置 extraData（PoA）
* 设置 gas limit 调整规则
* 设置 beacon randomness（PoS）
* 设置 proposer payload ID（L2）

### **② Finalize()**

输入：header + execution result (state, receipts)
输出：填入：

* stateRoot
* transactionsRoot
* receiptsRoot
* logsBloom
* baseFee（EIP-1559 / blob fee）
* blob gas used（EIP-4844）

### **③ Seal()（出块签名或挖矿）**

PoW：执行 Proof-of-Work 直到 nonce 合法
PoA：签名 block header
PoS：由 proposer 使用 beacon client 生成 RANDAO/签名
L2（OP）：向 L1 提交 output root

### **④ VerifySeal()**

用于验证其他节点产生的区块是否合法（同步/验证环节）

---

## 2.2 Miner（出块器）需要的所有资源：

* TxPool（LegacyPool + BlobPool）
* StateDB（基于 parent 的世界状态）
* EVM / Gas 会计器
* 共识引擎（上述接口）
* ChainIndexer / BlockWriter
* P2P 广播器

---

# 三、 深入解读系列

---

# 📘 **第一篇：矿工出块整体流程与系统架构**

内容：

* 为什么矿工不只是“执行交易 + 拼区块”
* 全链路架构图（RPC → Pool → State → EVM → Block → Consensus）
* P2P 接收交易 + TxPool 行为简述
* 出块循环（mining loop/ sealing loop）
* 与共识模块的关系（接口层简介）
* 出块流程的伪代码（总览版）

---

# 📗 **第二篇：交易池（TxPool）与交易调度机制**

内容：

* LegacyPool 结构（pending/queue/priced/all）
* BlobPool（limbo/queue/bag 文件）与异步验证
* nonce 管理：pending → queued → promotable
* 手续费拍卖算法：tip 优先级、blob gas 限制、价格队列
* 交易选择器（TxSelector）全流程
* 交易冲突、替换、驱逐、GC

---

# 📙 **第三篇：状态转换与 EVM 执行（Miner 的核心）**

内容：

* 从 parent header 创建工作状态（StateDB）
* BlockContext / TxContext 填充逻辑
* 调度交易 → 执行 → gas 会计 → 错误处理
* write-set / dirty storage → Merkle Trie 更新
* receipts bloom 构建
* BlobGas / BaseFee / ExcessBlobGas 的更新
* 结束后 finalize header


---

# 📕 **第四篇：区块构造、共识封装与广播**

内容：

* 区块数据结构：Header / Body / Ommers / BlobBundle
* Finalize() → 构造最终 header
* Seal()：PoW 挖矿 / PoA 签名 / PoS 预编译 / L2 output 生成
* 区块广播（tx 广播 vs block 广播）
* 快速同步节点如何处理新区块
* 典型攻击与防御（DoS、invalid tx spam）


---

# 四、完整矿工出块逻辑

这里以伪码的形式体现：

```go
for {
    parent := chain.CurrentBlock()

    // ========== 1. 准备 Header (共识模块参与) ==========
    header := MakeHeader(parent)
    consensus.Prepare(header)

    // ========== 2. 准备 StateDB ==========
    statedb := state.New(parent.Root)

    // ========== 3. 选择交易 ==========
    txs := txpool.Select(sorted by price/nonce/blob constrains)

    // ========== 4. 执行交易 ==========
    receipts := []
    for tx in txs {
        result := evm.ApplyTransaction(header, statedb, tx)
        if result.Success {
            receipts.append(result.receipt)
        } else {
            // invalid during execution → drop & continue
        }
    }

    // ========== 5. Finalize (共识) ==========
    consensus.Finalize(header, statedb, receipts)

    // ========== 6. Seal Block ==========
    block := types.NewBlock(header, txs, receipts)
    sealed := consensus.Seal(block)

    // ========== 7. 写入链 & 广播 ==========
    chain.InsertBlock(sealed)
    p2p.BroadcastBlock(sealed)
}
```

后面会逐个专题展开详细解读。
