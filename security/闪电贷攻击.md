
## 1. é—ªç”µè´·æ”»å‡»æ ¸å¿ƒæ¦‚å¿µ

### 1.1 ä»€ä¹ˆæ˜¯é—ªç”µè´·ï¼Ÿ

**é—ªç”µè´·** æ˜¯ä¸€ç§æ— æŠµæŠ¼è´·æ¬¾ï¼Œå…è®¸ç”¨æˆ·åœ¨**ä¸€ä¸ªäº¤æ˜“å†…**å€Ÿå‡ºå·¨é¢èµ„é‡‘ï¼Œä½†å¿…é¡»åœ¨**åŒä¸€äº¤æ˜“å†…å½’è¿˜**æœ¬é‡‘å’Œè´¹ç”¨ï¼Œå¦åˆ™æ•´ä¸ªäº¤æ˜“ä¼šå›æ»šã€‚

```go
// é—ªç”µè´·çš„åŸºæœ¬æ¦‚å¿µ
type FlashLoan struct {
    Borrower    common.Address
    Asset       common.Address  
    Amount      *big.Int
    Fee         *big.Int        // é€šå¸¸ 0.09%
    Deadline    *big.Int        // å¿…é¡»åœ¨åŒä¸€äº¤æ˜“å†…å½’è¿˜
}
```

### 1.2 é—ªç”µè´·æ”»å‡»çš„æœ¬è´¨

æ”»å‡»è€…åˆ©ç”¨é—ªç”µè´·**ä¸´æ—¶è·å¾—å·¨é¢èµ„æœ¬**ï¼Œæ“çºµå¸‚åœºä»·æ ¼æˆ–åè®®é€»è¾‘ï¼Œåœ¨å•ç¬”äº¤æ˜“ä¸­å®Œæˆæ”»å‡»å¹¶è·åˆ©ã€‚

```mermaid
sequenceDiagram
    participant A as æ”»å‡»è€…
    participant F as é—ªç”µè´·åè®®
    participant D as DeFi åè®®
    participant O as é¢„è¨€æœº

    A->>F: å€Ÿå‡ºå·¨é¢é—ªç”µè´·
    Note over A: è·å¾—ä¸´æ—¶å·¨é¢èµ„é‡‘
    
    A->>D: æ“çºµå¸‚åœºä»·æ ¼/åè®®çŠ¶æ€
    A->>O: å½±å“é¢„è¨€æœºä»·æ ¼
    
    A->>D: åˆ©ç”¨è¢«æ“çºµçš„çŠ¶æ€è·åˆ©
    
    A->>F: å½’è¿˜é—ªç”µè´· + è´¹ç”¨
    Note over A: å‰©ä½™åˆ©æ¶¦å½’æ”»å‡»è€…
```

---

## 2. é—ªç”µè´·åè®®å®ç°

### 2.1 åŸºç¡€é—ªç”µè´·åˆçº¦ï¼ˆSolidityï¼‰

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SimpleFlashLoan is ReentrancyGuard {
    address public owner;
    uint256 public constant FEE_BPS = 9; // 0.09% è´¹ç”¨
    
    event FlashLoanExecuted(
        address indexed borrower,
        address indexed asset,
        uint256 amount,
        uint256 fee
    );
    
    constructor() {
        owner = msg.sender;
    }
    
    // æ‰§è¡Œé—ªç”µè´·
    function flashLoan(
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external nonReentrant {
        require(_amount > 0, "Amount must be positive");
        
        IERC20 token = IERC20(_token);
        uint256 balanceBefore = token.balanceOf(address(this));
        require(balanceBefore >= _amount, "Insufficient liquidity");
        
        // 1. å‘å€Ÿæ¬¾äººè½¬è´¦
        require(token.transfer(msg.sender, _amount), "Transfer failed");
        
        // 2. æ‰§è¡Œå›è°ƒå‡½æ•°
        (bool success, ) = msg.sender.call(
            abi.encodeWithSignature(
                "executeOperation(address,uint256,uint256,bytes)",
                _token,
                _amount,
                _fee,
                _data
            )
        );
        require(success, "Callback failed");
        
        // 3. è®¡ç®—åº”å½’è¿˜é‡‘é¢
        uint256 fee = (_amount * FEE_BPS) / 10000;
        uint256 amountToReturn = _amount + fee;
        
        // 4. éªŒè¯èµ„é‡‘å½’è¿˜
        uint256 balanceAfter = token.balanceOf(address(this));
        require(
            balanceAfter >= balanceBefore + fee,
            "Flash loan not repaid"
        );
        
        emit FlashLoanExecuted(msg.sender, _token, _amount, fee);
    }
    
    // æ·»åŠ æµåŠ¨æ€§
    function addLiquidity(address _token, uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        IERC20(_token).transferFrom(msg.sender, address(this), _amount);
    }
}
```

### 2.2 æ”»å‡»è€…åˆçº¦æ¥å£

```solidity
// æ”»å‡»è€…å¿…é¡»å®ç°çš„æ¥å£
interface IFlashLoanBorrower {
    function executeOperation(
        address _token,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _data
    ) external returns (bool);
}

// æ”»å‡»è€…åŸºç¡€åˆçº¦
contract FlashLoanAttacker is IFlashLoanBorrower {
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    // å¿…é¡»å®ç°çš„å›è°ƒå‡½æ•°
    function executeOperation(
        address _token,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _data
    ) external override returns (bool) {
        // åœ¨è¿™é‡Œæ‰§è¡Œæ”»å‡»é€»è¾‘
        _performAttack(_token, _amount, _data);
        
        // å½’è¿˜èµ„é‡‘
        IERC20(_token).transfer(msg.sender, _amount + _fee);
        
        return true;
    }
    
    // æå–åˆ©æ¶¦
    function withdrawProfits(address _token) external {
        require(msg.sender == owner, "Only owner");
        uint256 balance = IERC20(_token).balanceOf(address(this));
        IERC20(_token).transfer(owner, balance);
    }
    
    // æ”»å‡»é€»è¾‘ç”±å…·ä½“æ”»å‡»ç±»å‹å®ç°
    function _performAttack(
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) internal virtual;
}
```

---

## 3. Golang é—ªç”µè´·æ”»å‡»æ¨¡æ‹Ÿå™¨

### 3.1 æ”»å‡»æ¨¡æ‹Ÿæ¡†æ¶

```go
package main

import (
    "context"
    "fmt"
    "math/big"
    "time"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/types"
)

// é—ªç”µè´·æ”»å‡»æ¨¡æ‹Ÿå™¨
type FlashLoanAttackSimulator struct {
    flashLoanPool *FlashLoanPool
    dexProtocols  []DEXProtocol
    lendingPools  []LendingProtocol
    oracles       []PriceOracle
}

type AttackResult struct {
    AttackType    string
    Profit        *big.Int
    GasUsed       *big.Int
    Success       bool
    Error         string
    ExecutionTime time.Duration
}

// æ¨¡æ‹Ÿé—ªç”µè´·æ”»å‡»
func (sim *FlashLoanAttackSimulator) SimulateAttack(ctx context.Context, attackType string, loanAmount *big.Int) (*AttackResult, result) {
    startTime := time.Now()
    
    var profit *big.Int
    var err error
    
    switch attackType {
    case "oracle_manipulation":
        profit, err = sim.simulateOracleManipulation(ctx, loanAmount)
    case "arbitrage_amplification":
        profit, err = sim.simulateArbitrageAmplification(ctx, loanAmount)
    case "governance_attack":
        profit, err = sim.simulateGovernanceAttack(ctx, loanAmount)
    case "liquidation_cascade":
        profit, err = sim.simulateLiquidationCascade(ctx, loanAmount)
    default:
        return nil, fmt.Errorf("unknown attack type: %s", attackType)
    }
    
    executionTime := time.Since(startTime)
    
    return &AttackResult{
        AttackType:    attackType,
        Profit:        profit,
        Success:       err == nil,
        Error:         errToString(err),
        ExecutionTime: executionTime,
    }, nil
}
```

### 3.2 é¢„è¨€æœºæ“çºµæ”»å‡»

```go
// é¢„è¨€æœºæ“çºµæ”»å‡» - æœ€å¸¸è§çš„é—ªç”µè´·æ”»å‡»
func (sim *FlashLoanAttackSimulator) simulateOracleManipulation(
    ctx context.Context, 
    loanAmount *big.Int,
) (*big.Int, error) {
    
    fmt.Println("ğŸš¨ å¼€å§‹é¢„è¨€æœºæ“çºµæ”»å‡»æ¨¡æ‹Ÿ...")
    
    // 1. å€Ÿå…¥é—ªç”µè´·
    fmt.Printf("1. å€Ÿå…¥é—ªç”µè´·: %s ETH\n", formatEther(loanAmount))
    
    // 2. æ“çºµDEXä»·æ ¼
    fmt.Println("2. æ“çºµDEXä»·æ ¼...")
    manipulatedPrice, err := sim.manipulateDEXPrice(loanAmount)
    if err != nil {
        return nil, fmt.Errorf("ä»·æ ¼æ“çºµå¤±è´¥: %v", err)
    }
    
    // 3. åˆ©ç”¨è¢«æ“çºµçš„ä»·æ ¼åœ¨å€Ÿè´·åè®®è·åˆ©
    fmt.Println("3. åœ¨å€Ÿè´·åè®®è¿›è¡Œæ¶æ„æ“ä½œ...")
    protocolProfit, err := sim.exploitLendingProtocol(manipulatedPrice)
    if err != nil {
        return nil, fmt.Errorf("åè®®åˆ©ç”¨å¤±è´¥: %v", err)
    }
    
    // 4. æ¢å¤ä»·æ ¼ï¼ˆå¯é€‰ï¼‰
    fmt.Println("4. æ¢å¤DEXä»·æ ¼...")
    sim.restoreDEXPrice(loanAmount)
    
    // 5. è®¡ç®—å‡€æ”¶ç›Š
    fee := new(big.Int).Div(new(big.Int).Mul(loanAmount, big.NewInt(9)), big.NewInt(10000))
    netProfit := new(big.Int).Sub(protocolProfit, fee)
    
    fmt.Printf("âœ… æ”»å‡»å®Œæˆ! å‡€æ”¶ç›Š: %s ETH\n", formatEther(netProfit))
    
    return netProfit, nil
}

// æ“çºµDEXä»·æ ¼
func (sim *FlashLoanAttackSimulator) manipulateDEXPrice(loanAmount *big.Int) (*big.Float, error) {
    // é€‰æ‹©æµåŠ¨æ€§è¾ƒä½çš„äº¤æ˜“å¯¹
    targetPool := sim.findVulnerablePool()
    
    // å¤§é‡ä¹°å…¥ï¼Œæ€¥å‰§æ¨é«˜ä»·æ ¼
    priceBefore := sim.getCurrentPrice(targetPool)
    fmt.Printf("   å½“å‰ä»·æ ¼: %s\n", priceBefore.String())
    
    // æ‰§è¡Œå¤§é¢äº¤æ˜“æ“çºµä»·æ ¼
    err := sim.executeLargeSwap(targetPool, loanAmount, "buy")
    if err != nil {
        return nil, err
    }
    
    priceAfter := sim.getCurrentPrice(targetPool)
    fmt.Printf("   æ“çºµåä»·æ ¼: %s (æ¶¨å¹…: %.2f%%)\n", 
        priceAfter.String(), 
        calculatePercentageChange(priceBefore, priceAfter))
    
    return priceAfter, nil
}
```

### 3.3 å¥—åˆ©æ”¾å¤§æ”»å‡»

```go
// å¥—åˆ©æ”¾å¤§æ”»å‡» - ç”¨é—ªç”µè´·æ”¾å¤§å¥—åˆ©è§„æ¨¡
func (sim *FlashLoanAttackSimulator) simulateArbitrageAmplification(
    ctx context.Context,
    loanAmount *big.Int,
) (*big.Int, error) {
    
    fmt.Println("ğŸš¨ å¼€å§‹å¥—åˆ©æ”¾å¤§æ”»å‡»æ¨¡æ‹Ÿ...")
    
    // 1. å‘ç°å¥—åˆ©æœºä¼š
    opportunity, err := sim.findSmallArbitrage()
    if err != nil {
        return nil, fmt.Errorf("æœªæ‰¾åˆ°å¥—åˆ©æœºä¼š: %v", err)
    }
    
    fmt.Printf("1. å‘ç°å°é¢å¥—åˆ©æœºä¼š: åˆ©æ¶¦ %s ETH\n", formatEther(opportunity.Profit))
    
    // 2. å¦‚æœæ²¡æœ‰é—ªç”µè´·ï¼Œåˆ©æ¶¦å¾ˆå°
    smallProfit := opportunity.Profit
    
    // 3. ä½¿ç”¨é—ªç”µè´·æ”¾å¤§è§„æ¨¡
    amplifiedProfit, err := sim.amplifyArbitrage(loanAmount, opportunity)
    if err != nil {
        return nil, fmt.Errorf("å¥—åˆ©æ”¾å¤§å¤±è´¥: %v", err)
    }
    
    // 4. è®¡ç®—æ”¾å¤§æ•ˆæœ
    amplification := new(big.Float).Quo(
        new(big.Float).SetInt(amplifiedProfit),
        new(big.Float).SetInt(smallProfit),
    )
    
    fmt.Printf("2. ä½¿ç”¨é—ªç”µè´·æ”¾å¤§å¥—åˆ©è§„æ¨¡\n")
    fmt.Printf("3. å°é¢åˆ©æ¶¦: %s ETH â†’ æ”¾å¤§ååˆ©æ¶¦: %s ETH\n", 
        formatEther(smallProfit), formatEther(amplifiedProfit))
    fmt.Printf("4. æ”¾å¤§å€æ•°: %sx\n", amplification.String())
    
    return amplifiedProfit, nil
}

// æ”¾å¤§å¥—åˆ©è§„æ¨¡
func (sim *FlashLoanAttackSimulator) amplifyArbitrage(
    loanAmount *big.Int,
    opportunity *ArbitrageOpportunity,
) (*big.Int, error) {
    
    // ä½¿ç”¨é—ªç”µè´·èµ„é‡‘æ‰§è¡Œå¤§è§„æ¨¡å¥—åˆ©
    scaledOpportunity := &ArbitrageOpportunity{
        TokenIn:   opportunity.TokenIn,
        TokenOut:  opportunity.TokenOut,
        DexBuy:    opportunity.DexBuy,
        DexSell:   opportunity.DexSell,
        BuyPrice:  opportunity.BuyPrice,
        SellPrice: opportunity.SellPrice,
        Amount:    loanAmount, // ä½¿ç”¨é—ªç”µè´·èµ„é‡‘
    }
    
    // æ‰§è¡Œå¥—åˆ©
    profit, err := sim.executeArbitrage(scaledOpportunity)
    if err != nil {
        return nil, err
    }
    
    // æ‰£é™¤é—ªç”µè´·è´¹ç”¨
    fee := new(big.Int).Div(new(big.Int).Mul(loanAmount, big.NewInt(9)), big.NewInt(10000))
    netProfit := new(big.Int).Sub(profit, fee)
    
    return netProfit, nil
}
```

---

## 4. çœŸå®æ”»å‡»æ¡ˆä¾‹åˆ†æ

### 4.1 Harvest Finance æ”»å‡»æ¨¡æ‹Ÿ

```go
// Harvest Finance æ”»å‡»å¤ç° (2020å¹´10æœˆ, æŸå¤± $2400ä¸‡)
type HarvestFinanceAttack struct {
    flashLoanPool common.Address
    harvestVault  common.Address
    usdc          common.Address
    usdt          common.Address
}

func (hfa *HarvestFinanceAttack) Execute() error {
    fmt.Println("ğŸ¯ å¤ç° Harvest Finance æ”»å‡»...")
    
    // æ”»å‡»æ­¥éª¤:
    // 1. é€šè¿‡é—ªç”µè´·å€Ÿå…¥å¤§é‡ USDC/USDT
    // 2. å­˜å…¥ Harvest èµ„é‡‘æ± ï¼Œæ¨é«˜è™šæ‹Ÿä»·æ ¼
    // 3. åˆ©ç”¨ä»·æ ¼è¯¯å·®æå–é¢å¤–ä»£å¸
    // 4. å½’è¿˜é—ªç”µè´·
    
    loanAmount := big.NewInt(1000000000) // 10äº¿ USDC
    
    // 1. å€Ÿå…¥é—ªç”µè´·
    fmt.Printf("1. å€Ÿå…¥é—ªç”µè´·: %s USDC\n", formatUnits(loanAmount, 6))
    
    // 2. æ“çºµä»·æ ¼
    fmt.Println("2. æ“çºµ Harvest èµ„é‡‘æ± ä»·æ ¼...")
    virtualPriceBefore := big.NewInt(1000000) // 1.0
    virtualPriceAfter := big.NewInt(1001000)  // 1.001 - è¢«æ“çºµå
    
    // 3. åˆ©ç”¨ä»·æ ¼å·®å¼‚
    profit := hfa.exploitPriceDifference(loanAmount, virtualPriceBefore, virtualPriceAfter)
    
    // 4. å½’è¿˜é—ªç”µè´·
    fee := new(big.Int).Div(new(big.Int).Mul(loanAmount, big.NewInt(9)), big.NewInt(10000))
    netProfit := new(big.Int).Sub(profit, fee)
    
    fmt.Printf("3. æ”»å‡»åˆ©æ¶¦: %s USDC\n", formatUnits(netProfit, 6))
    fmt.Printf("âœ… Harvest Finance æ”»å‡»å¤ç°å®Œæˆ\n")
    
    return nil
}

func (hfa *HarvestFinanceAttack) exploitPriceDifference(
    depositAmount *big.Int,
    priceBefore *big.Int,
    priceAfter *big.Int,
) *big.Int {
    
    // è®¡ç®—ä»·æ ¼æ“çºµå¸¦æ¥çš„å¥—åˆ©ç©ºé—´
    sharesMinted := new(big.Int).Div(
        new(big.Int).Mul(depositAmount, big.NewInt(1e18)),
        priceBefore,
    )
    
    valueAfterManipulation := new(big.Int).Div(
        new(big.Int).Mul(sharesMinted, priceAfter),
        big.NewInt(1e18),
    )
    
    profit := new(big.Int).Sub(valueAfterManipulation, depositAmount)
    return profit
}
```

### 4.2 PancakeBunny æ”»å‡»æ¨¡æ‹Ÿ

```go
// PancakeBunny æ”»å‡»å¤ç° (2021å¹´5æœˆ, æŸå¤± $4500ä¸‡)
type PancakeBunnyAttack struct {
    pancakeSwap common.Address
    bunnyVault  common.Address
    wbnb        common.Address
    busd        common.Address
}

func (pba *PancakeBunnyAttack) Execute() error {
    fmt.Println("ğŸ¯ å¤ç° PancakeBunny æ”»å‡»...")
    
    // æ”»å‡»åŸç†:
    // 1. é—ªç”µè´·å€Ÿå…¥å¤§é‡ BNB
    // 2. åœ¨ PancakeSwap ä¸­æ“çºµ BNB-BUSD ä»·æ ¼
    // 3. åˆ©ç”¨ Bunny çŸ¿æ± çš„ mint å‡½æ•°æ¼æ´
    // 4. æå–è¶…é‡ BUNNY ä»£å¸
    
    loanAmount := big.NewInt(5000000000000000000) // 5000 BNB
    
    fmt.Printf("1. å€Ÿå…¥é—ªç”µè´·: %s BNB\n", formatEther(loanAmount))
    fmt.Println("2. æ“çºµ BNB-BUSD ä»·æ ¼...")
    
    // æ“çºµä»·æ ¼
    priceImpact := pba.manipulateBNBPrice(loanAmount)
    fmt.Printf("   ä»·æ ¼å½±å“: %.4f%%\n", priceImpact)
    
    // åˆ©ç”¨æ¼æ´ mint è¶…é‡ä»£å¸
    bunnyProfit, err := pba.exploitMintVulnerability(loanAmount)
    if err != nil {
        return err
    }
    
    fmt.Printf("3. è·å–è¶…é‡ BUNNY: %s\n", formatEther(bunnyProfit))
    fmt.Printf("4. å–å‡º BUNNY è·åˆ©...\n")
    
    finalProfit := pba.sellBunnyForProfit(bunnyProfit)
    fmt.Printf("âœ… æœ€ç»ˆåˆ©æ¶¦: %s BNB\n", formatEther(finalProfit))
    
    return nil
}
```

---

## 5. é˜²æŠ¤æªæ–½

### 5.1 åè®®çº§é˜²æŠ¤

```solidity
// å¢å¼ºçš„é—ªç”µè´·é˜²æŠ¤åˆçº¦
contract ProtectedFlashLoan {
    using SafeERC20 for IERC20;
    
    mapping(address => bool) public whitelistedBorrowers;
    mapping(address => uint256) public maxLoanAmounts;
    uint256 public totalLoanLimit;
    
    // æ—¶é—´é”é˜²æŠ¤
    struct LoanRecord {
        uint256 timestamp;
        uint256 amount;
        address borrower;
    }
    
    mapping(bytes32 => LoanRecord) public loanRecords;
    
    // å¢å¼ºçš„é—ªç”µè´·å‡½æ•°
    function protectedFlashLoan(
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external {
        require(whitelistedBorrowers[msg.sender], "Borrower not whitelisted");
        require(_amount <= maxLoanAmounts[_token], "Amount exceeds limit");
        require(_amount <= totalLoanLimit, "Exceeds total limit");
        
        // è®°å½•è´·æ¬¾ä¿¡æ¯
        bytes32 loanId = keccak256(abi.encodePacked(msg.sender, _token, _amount, block.timestamp));
        loanRecords[loanId] = LoanRecord(block.timestamp, _amount, msg.sender);
        
        // æ‰§è¡Œæ ‡å‡†é—ªç”µè´·é€»è¾‘
        _executeFlashLoan(_token, _amount, _data);
        
        // éªŒè¯çŠ¶æ€å®Œæ•´æ€§
        _validateStateIntegrity(_token);
    }
    
    // çŠ¶æ€å®Œæ•´æ€§éªŒè¯
    function _validateStateIntegrity(address _token) internal view {
        // æ£€æŸ¥å…³é”®çŠ¶æ€å˜é‡æ˜¯å¦è¢«å¼‚å¸¸ä¿®æ”¹
        // è¿™éœ€è¦æ ¹æ®å…·ä½“åè®®é€»è¾‘å®ç°
    }
}
```

### 5.2 ä»·æ ¼é¢„è¨€æœºé˜²æŠ¤

```solidity
// é˜²æ“çºµçš„ä»·æ ¼é¢„è¨€æœº
contract ManipulationResistantOracle {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 blockNumber;
    }
    
    mapping(address => PriceData[]) public priceHistory;
    uint256 public constant TIME_WINDOW = 1 hours;
    uint256 public constant MAX_PRICE_CHANGE = 20e16; // 20%
    
    function updatePrice(address _token, uint256 _price) external {
        PriceData[] storage history = priceHistory[_token];
        
        // æ£€æŸ¥ä»·æ ¼å˜åŒ–ç‡
        if (history.length > 0) {
            PriceData memory last = history[history.length - 1];
            uint256 change = _calculatePriceChange(last.price, _price);
            require(change <= MAX_PRICE_CHANGE, "Price change too large");
        }
        
        // ä½¿ç”¨ TWAPï¼ˆæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼‰
        uint256 twap = _calculateTWAP(_token);
        uint256 deviation = _calculatePriceChange(twap, _price);
        require(deviation <= 5e16, "Deviation from TWAP too large"); // 5%
        
        // è®°å½•ä»·æ ¼
        history.push(PriceData(_price, block.timestamp, block.number));
        
        // æ¸…ç†æ—§æ•°æ®
        _cleanOldData(_token);
    }
    
    function _calculateTWAP(address _token) internal view returns (uint256) {
        // è®¡ç®—æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼
        PriceData[] storage history = priceHistory[_token];
        if (history.length == 0) return 0;
        
        uint256 totalWeight;
        uint256 weightedPrice;
        
        for (uint i = 0; i < history.length; i++) {
            uint256 timeDiff = i == history.length - 1 ? 
                block.timestamp - history[i].timestamp :
                history[i+1].timestamp - history[i].timestamp;
                
            weightedPrice += history[i].price * timeDiff;
            totalWeight += timeDiff;
        }
        
        return weightedPrice / totalWeight;
    }
}
```

### 5.3 Golang æ”»å‡»æ£€æµ‹ç³»ç»Ÿ

```go
// é—ªç”µè´·æ”»å‡»æ£€æµ‹ç³»ç»Ÿ
type FlashLoanAttackDetector struct {
    transactionMonitor *TransactionMonitor
    patternDatabase    *AttackPatternDB
    alertSystem        *AlertSystem
}

// å®æ—¶æ£€æµ‹é—ªç”µè´·æ”»å‡»
func (detector *FlashLoanAttackDetector) MonitorTransactions(ctx context.Context) {
    txCh := make(chan *types.Transaction)
    
    go detector.transactionMonitor.SubscribeLargeTransactions(txCh)
    
    for {
        select {
        case tx := <-txCh:
            // åˆ†æäº¤æ˜“ç‰¹å¾
            riskScore, err := detector.analyzeTransactionRisk(tx)
            if err != nil {
                continue
            }
            
            if riskScore > 0.8 { // é«˜é£é™©
                detector.alertSystem.TriggerAlert(&Alert{
                    Type:       "flash_loan_attack",
                    RiskScore:  riskScore,
                    Transaction: tx,
                    Timestamp:  time.Now(),
                })
                
                fmt.Printf("ğŸš¨ æ£€æµ‹åˆ°æ½œåœ¨é—ªç”µè´·æ”»å‡»: %s, é£é™©åˆ†æ•°: %.2f\n", 
                    tx.Hash().Hex(), riskScore)
            }
            
        case <-ctx.Done():
            return
        }
    }
}

// åˆ†æäº¤æ˜“é£é™©
func (detector *FlashLoanAttackDetector) analyzeTransactionRisk(tx *types.Transaction) (float64, error) {
    var riskScore float64
    
    // 1. æ£€æŸ¥æ˜¯å¦è°ƒç”¨é—ªç”µè´·åˆçº¦
    if detector.isFlashLoanCall(tx) {
        riskScore += 0.3
    }
    
    // 2. æ£€æŸ¥äº¤æ˜“é‡‘é¢
    if tx.Value().Cmp(big.NewInt(1000000000000000000)) > 0 { // > 1 ETH
        riskScore += 0.2
    }
    
    // 3. æ£€æŸ¥æ˜¯å¦è°ƒç”¨å¤šä¸ªDeFiåè®®
    protocolCount := detector.countDeFiProtocolCalls(tx)
    if protocolCount >= 3 {
        riskScore += 0.3
    }
    
    // 4. æ£€æŸ¥æ¨¡å¼åŒ¹é…
    if detector.matchesKnownAttackPattern(tx) {
        riskScore += 0.2
    }
    
    return riskScore, nil
}
```

---

## 6. æ€»ç»“

### 6.1 é—ªç”µè´·æ”»å‡»ç‰¹ç‚¹

| ç‰¹å¾ | æè¿° |
|------|------|
| **æ— èµ„æœ¬è¦æ±‚** | æ”»å‡»è€…æ— éœ€è‡ªæœ‰èµ„é‡‘ |
| **é«˜ç ´åæ€§** | å¯é€ æˆæ•°ç™¾ä¸‡ç¾å…ƒæŸå¤± |
| **å•äº¤æ˜“å®Œæˆ** | æ‰€æœ‰æ“ä½œåœ¨ä¸€ä¸ªäº¤æ˜“å†… |
| **æŠ€æœ¯å¤æ‚** | éœ€è¦æ·±å…¥äº†è§£å¤šä¸ªåè®® |

### 6.2 å¸¸è§æ”»å‡»å‘é‡

1. **ğŸ”® é¢„è¨€æœºæ“çºµ** - æœ€å¸¸è§ï¼ˆHarvest Financeï¼‰
2. **ğŸ”„ å¥—åˆ©æ”¾å¤§** - æ”¾å¤§æ­£å¸¸å¥—åˆ©æœºä¼š  
3. **ğŸ›ï¸ æ²»ç†æ”»å‡»** - æ“çºµæ²»ç†æŠ•ç¥¨
4. **ğŸ’¥ æ¸…ç®—çº§è”** - è§¦å‘å¤§è§„æ¨¡æ¸…ç®—
5. **ğŸª™ ä»£å¸é“¸é€ æ¼æ´** - åˆ©ç”¨mintå‡½æ•°ç¼ºé™·

### 6.3 é˜²æŠ¤ç­–ç•¥

1. **âœ… ä½¿ç”¨TWAPé¢„è¨€æœº** - é˜²ä»·æ ¼æ“çºµ
2. **âœ… è®¾ç½®äº¤æ˜“é™åˆ¶** - å•ç¬”äº¤æ˜“ä¸Šé™
3. **âœ… å®æ–½æ—¶é—´é”** - å»¶è¿Ÿå…³é”®æ“ä½œ
4. **âœ… å¤šé‡éªŒè¯** - å¤šä¸ªæ•°æ®æºäº¤å‰éªŒè¯
5. **âœ… å®æ—¶ç›‘æ§** - å¼‚å¸¸äº¤æ˜“æ£€æµ‹

é—ªç”µè´·æœ¬èº«æ˜¯DeFiçš„é‡è¦åˆ›æ–°ï¼Œä½†ä¹Ÿè¢«æ¶æ„åˆ©ç”¨ã€‚ç†è§£è¿™äº›æ”»å‡»æœºåˆ¶å¯¹äºå¼€å‘å®‰å…¨çš„DeFiåè®®å’Œä¿æŠ¤ç”¨æˆ·èµ„é‡‘è‡³å…³é‡è¦ã€‚